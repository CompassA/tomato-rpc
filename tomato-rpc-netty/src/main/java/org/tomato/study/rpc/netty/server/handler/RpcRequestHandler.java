package org.tomato.study.rpc.netty.server.handler;

import io.netty.channel.ChannelHandler;
import org.apache.commons.lang3.StringUtils;
import org.tomato.study.rpc.core.ProviderRegistry;
import org.tomato.study.rpc.core.Serializer;
import org.tomato.study.rpc.core.ServerHandler;
import org.tomato.study.rpc.core.data.Command;
import org.tomato.study.rpc.core.data.CommandFactory;
import org.tomato.study.rpc.core.data.CommandType;
import org.tomato.study.rpc.core.data.Header;
import org.tomato.study.rpc.netty.data.RpcRequest;
import org.tomato.study.rpc.netty.serializer.SerializerHolder;

import java.lang.reflect.Method;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * @author Tomato
 * Created on 2021.04.18
 */
@ChannelHandler.Sharable
public class RpcRequestHandler implements ProviderRegistry, ServerHandler {

    /**
     * server provider map:
     * id generated by this#providerId -> provider instance
     */
    private final ConcurrentMap<String, Object> providerMap = new ConcurrentHashMap<>(0);

    @Override
    public <T> void register(String vip, T instance, Class<T> serviceInterface) {
        if (StringUtils.isBlank(vip) || instance == null || !serviceInterface.isInterface()) {
            throw new IllegalCallerException("register invalid data");
        }
        providerMap.put(providerId(serviceInterface.getName(), vip), instance);
    }

    @Override
    public Command handle(Command command) throws Exception {
        // deserialize the RPC request
        Header header = command.getHeader();
        Serializer serializer = SerializerHolder.getSerializer(header.getSerializeType());
        RpcRequest clientRequest = serializer.deserialize(command.getBody(), RpcRequest.class);

        // search the RPC service provider
        String providerId = providerId(clientRequest.getInterfaceName(), clientRequest.getServiceVIP());
        Object providerInstance = providerMap.get(providerId);
        if (providerInstance == null) {
            throw new IllegalCallerException("no such provider named " + providerId);
        }

        // search the method of the provider
        Method method = providerInstance.getClass().getMethod(clientRequest.getMethodName(), clientRequest.getArgsType());

        // invoke the method and write response data
        Object result = method.invoke(providerInstance, clientRequest.getParameters());
        return CommandFactory.INSTANCE.responseCommand(
                header.getId(), result, serializer, CommandType.RPC_RESPONSE);
    }

    @Override
    public CommandType getType() {
        return CommandType.RPC_REQUEST;
    }

    private String providerId(String interfaceName, String vip) {
        return interfaceName + "$" + vip;
    }
}
